<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tournament Details - Chess Tournament Manager</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
  <link rel="stylesheet" href="css/styles.css">
  <style>
    /* Custom styles for pairing error modal */
    #pairingErrorModal .modal-dialog {
      max-width: 90%;
      width: 800px;
    }
    #pairingErrorModal .modal-content {
      box-shadow: 0 0 30px rgba(0,0,0,0.6);
      border: none;
    }
    #pairingErrorModal .modal-backdrop.show {
      opacity: 0.8;
      cursor: pointer; /* Show pointer cursor to indicate clickable */
    }
    #pairingErrorModal .modal-body {
      padding: 2.5rem;
    }
    
    /* Custom button styles with gradient and animation */
    .btn-gradient-primary {
      background-image: linear-gradient(to right, #4361ee, #3a0ca3);
      border: none;
      color: white;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(65, 97, 238, 0.3);
    }
    
    .btn-gradient-primary:hover {
      background-image: linear-gradient(to right, #3a0ca3, #4361ee);
      transform: translateY(-2px);
      box-shadow: 0 7px 15px rgba(65, 97, 238, 0.4);
      color: white;
    }
    
    .btn-gradient-success {
      background-image: linear-gradient(to right, #38b000, #008000);
      border: none;
      color: white;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(56, 176, 0, 0.3);
    }
    
    .btn-gradient-success:hover {
      background-image: linear-gradient(to right, #008000, #38b000);
      transform: translateY(-2px);
      box-shadow: 0 7px 15px rgba(56, 176, 0, 0.4);
      color: white;
    }
    
    .round-container {
      border: 1px solid #e9ecef;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 25px;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.05);
      background-color: #ffffff;
    }
    
    .round-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      border-bottom: 1px solid #e9ecef;
      padding-bottom: 10px;
    }
    
    .round-footer {
      display: flex;
      justify-content: flex-end;
      margin-top: 15px;
      padding-top: 10px;
      border-top: 1px solid #e9ecef;
    }
    
    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(65, 97, 238, 0.4);
      }
      70% {
        box-shadow: 0 0 0 10px rgba(65, 97, 238, 0);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(65, 97, 238, 0);
      }
    }
    
    .btn-pulse {
      animation: pulse 1.5s infinite;
    }
  </style>
</head>
<body>
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
    <div class="container">
      <a class="navbar-brand" href="/">Chess Tournament Manager</a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav ms-auto">
          <li class="nav-item">
            <a class="nav-link active" href="/tournaments">Tournaments</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/tournament-guide">Guide</a>
          </li>
          <li class="nav-item" id="auth-nav-item">
            <a class="nav-link" href="/login">Login</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  <div class="container py-5">
    <div id="tournament-details">
      <div class="text-center py-5">
        <div class="spinner-border" role="status">
          <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-2">Loading tournament details...</p>
      </div>
    </div>
  </div>

  <!-- Confirmation Modal -->
  <div class="modal fade" id="confirmationModal" tabindex="-1" aria-labelledby="confirmationModalLabel" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="confirmationModalLabel">Confirmation</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" id="confirmationModalBody">
          Are you sure you want to proceed?
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
          <button type="button" class="btn btn-primary" id="confirmModalBtn">Yes</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Pairing Error Dialog -->
  <div class="modal fade" id="pairingErrorModal" tabindex="-1" aria-labelledby="pairingErrorModalLabel" aria-hidden="true" data-bs-backdrop="static">
    <div class="modal-dialog modal-dialog-centered modal-lg">
      <div class="modal-content">
        <div class="modal-header bg-danger text-white">
          <h5 class="modal-title" id="pairingErrorModalLabel">Pairing Error</h5>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body text-center p-5" id="pairingErrorModalBody">
          <i class="bi bi-exclamation-triangle-fill text-danger fs-1 mb-3"></i>
          <p class="fs-4 my-4" id="pairingErrorMessage" style="white-space: pre-line;"></p>
        </div>
        <div class="modal-footer justify-content-center">
          <button type="button" class="btn btn-primary btn-lg px-5" data-bs-dismiss="modal">OK</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Toast Container -->
  <div class="toast-container position-fixed top-0 start-50 translate-middle-x p-3" style="z-index: 1080;">
    <div id="notificationToast" class="toast align-items-center text-white border-0" role="alert" aria-live="assertive" aria-atomic="true">
      <div class="d-flex">
        <div class="toast-body" id="toastMessage">
          Notification message
        </div>
        <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
      </div>
    </div>
  </div>

  <footer class="bg-dark text-white py-4 mt-auto">
    <div class="container text-center">
      <p>&copy; 2025 Chess Tournament Manager. All rights reserved.</p>
    </div>
  </footer>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script src="/js/auth-common.js"></script>
  <script>
    // Get tournament ID from URL
    const urlParams = new URLSearchParams(window.location.search);
    const tournamentId = urlParams.get('id') || localStorage.getItem('currentTournamentId');
    const token = localStorage.getItem('token');
    const user = JSON.parse(localStorage.getItem('user') || '{}');
    
    console.log('Tournament details page - Tournament ID from URL or localStorage:', tournamentId);
    
    // Helper function to show toast notifications
    function showToast(message, type = 'success') {
      const toast = document.getElementById('notificationToast');
      
      // Remove any existing background classes
      toast.classList.remove('bg-success', 'bg-danger', 'bg-info', 'bg-warning');
      
      // Add the appropriate background class
      toast.classList.add(`bg-${type}`);
      
      // Set the message
      document.getElementById('toastMessage').textContent = message;
      
      // Show the toast
      const bsToast = new bootstrap.Toast(toast, { delay: 3000 });
      bsToast.show();
    }
    
    // Fetch tournament details
    async function fetchTournamentDetails() {
      try {
        console.log('Fetching tournament details for ID:', tournamentId);
        
        const headers = {
          'Content-Type': 'application/json'
        };
        
        // Add authorization token if available
        if (token) {
          headers['Authorization'] = `Bearer ${token}`;
        }
        
        const response = await fetch(`/api/tournaments/${tournamentId}`, {
          headers
        });
        
        if (!response.ok) {
          const errorData = await response.json();
          console.error('Failed to fetch tournament details:', errorData);
          throw new Error(errorData.error || 'Failed to fetch tournament details');
        }
        
        const data = await response.json();
        console.log('Tournament data received:', data);
        
        if (!data || !data.data || !data.data.tournament) {
          console.error('Invalid tournament data format:', data);
          throw new Error('Invalid tournament data received from server');
        }
        
        const tournament = data.data.tournament;
        
        // Add event listeners for Google Sheets functionality
        addGoogleSheetsEventListeners(tournament);
        
        return data.data;
      } catch (error) {
        console.error('Error fetching tournament details:', error);
        document.getElementById('tournament-details').innerHTML = `
          <div class="alert alert-danger">
            Failed to load tournament details: ${error.message}. Please try again later.
            <br><br>
            <a href="/tournaments" class="btn btn-primary">Back to Tournaments</a>
          </div>
        `;
        return null;
      }
    }
    
    // Render tournament details
    function renderTournamentDetails(data) {
      if (!data) {
        document.getElementById('tournament-details').innerHTML = `
          <div class="alert alert-danger">
            Failed to load tournament details. Please try again later.
          </div>
        `;
        return;
      }
      
      const { tournament, matches } = data;
      const startDate = new Date(tournament.startDate).toLocaleDateString();
      const endDate = new Date(tournament.endDate).toLocaleDateString();
      
      let statusBadge = '';
      switch (tournament.status) {
        case 'registration':
          statusBadge = '<span class="badge bg-success">Registration Open</span>';
          break;
        case 'ongoing':
          statusBadge = '<span class="badge bg-primary">Ongoing</span>';
          break;
        case 'completed':
          statusBadge = '<span class="badge bg-secondary">Completed</span>';
          break;
      }
      
      // Check if user is logged in
      const isLoggedIn = !!token;
      
      // Check if user is the organizer
      const currentUser = JSON.parse(localStorage.getItem('user') || '{}');
      console.log('Current user:', currentUser);
      console.log('Tournament organizer:', tournament.organizer);
      
      // Compare user ID with tournament organizer ID
      // The user object has 'id' property while tournament.organizer might have '_id'
      const isOrganizer = isLoggedIn && tournament.organizer && 
        (tournament.organizer._id === currentUser.id || tournament.organizer === currentUser.id);
      
      console.log('Is organizer:', isOrganizer);
      
      // Check if user has the 'owner' role
      const isOwner = currentUser.role === 'owner';
      console.log('Is owner:', isOwner);
      
      // Check if tournament is created by the owner
      const isTournamentCreatedByOwner = tournament.createdByOwner === true;
      console.log('Is tournament created by owner:', isTournamentCreatedByOwner);
      
      console.log('Checking if user can manage tournament:', {
        isOrganizer,
        isOwner,
        isTournamentCreatedByOwner,
        userId: currentUser.id,
        userRole: currentUser.role,
        organizerId: tournament.organizer ? tournament.organizer._id : 'No organizer',
        createdByOwner: tournament.createdByOwner
      });
      
      // Generate HTML
      let html = `
        <div class="mb-4">
          <a href="/tournaments" class="btn btn-outline-secondary mb-3">
            <i class="bi bi-arrow-left"></i> Back to Tournaments
          </a>
          <div class="d-flex justify-content-between align-items-center">
            <h1>${tournament.name}</h1>
            <div>${statusBadge}</div>
          </div>
        </div>
        
        <div class="row">
          <div class="col-md-4">
            <div class="card mb-4">
              <div class="card-header">
                <h5 class="card-title mb-0">Tournament Information</h5>
              </div>
              <div class="card-body">
                <p><strong>Location:</strong> ${tournament.location}</p>
                <p><strong>Dates:</strong> ${startDate} - ${endDate}</p>
                <p><strong>Format:</strong> ${tournament.format}</p>
                <p><strong>Rounds:</strong> ${tournament.rounds}</p>
                <p><strong>Pairing System:</strong> ${getPairingSystemName(tournament.pairingAlgorithm)}</p>
                <div class="pairing-system-info small text-muted mb-2">
                  ${getPairingSystemDescription(tournament.pairingAlgorithm)}
                </div>
                <p><strong>Time Control:</strong> ${tournament.timeControl || 'Not specified'}</p>
                <p><strong>Participants:</strong> ${tournament.participants.length}/${tournament.maxParticipants}</p>
                <p><strong>Visibility:</strong> ${tournament.isPublic === false ? 
                  '<span class="badge bg-secondary">Private</span>' : 
                  '<span class="badge bg-success">Public</span>'}</p>
                <p><strong>Organizer:</strong> ${tournament.createdByOwner || (tournament.organizer && tournament.organizer.role === 'owner') ? 
                  '<span class="badge bg-primary">Owner</span>' : 
                  (tournament.organizer ? tournament.organizer.username : 'Unknown')}</p>
              </div>
            </div>
            
            <div class="card mb-4">
              <div class="card-header">
                <h5 class="card-title mb-0">Description</h5>
              </div>
              <div class="card-body">
                <p>${tournament.description || 'No description provided.'}</p>
              </div>
            </div>
            
            ${token ? `
              <div class="card mb-4">
                <div class="card-header">
                  <h5 class="card-title mb-0">Actions</h5>
                </div>
                <div class="card-body">
                  ${(tournament.organizer && tournament.organizer._id === user.id) || user.role === 'owner' || tournament.createdByOwner ? `
                    <button id="edit-tournament-btn" class="btn btn-outline-primary w-100 mb-2">Edit Tournament</button>
                    ${tournament.status === 'registration' ? `
                      <button id="start-tournament-btn" class="btn btn-success w-100 mb-2">Start Tournament</button>
                    ` : ''}
                    <button id="delete-btn" class="btn btn-outline-danger w-100">Delete Tournament</button>
                  ` : ''}
                </div>
              </div>
            ` : ''}
          </div>
          
          <div class="col-md-8">
            <ul class="nav nav-tabs mb-4" id="tournamentTabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="standings-tab" data-bs-toggle="tab" data-bs-target="#standings" type="button" role="tab">Standings</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="matches-tab" data-bs-toggle="tab" data-bs-target="#matches" type="button" role="tab">Matches</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="participants-tab" data-bs-toggle="tab" data-bs-target="#participants" type="button" role="tab">Participants</button>
              </li>
            </ul>
            
            <div class="tab-content" id="tournamentTabContent">
              <div class="tab-pane fade show active" id="standings" role="tabpanel">
                ${renderStandings(tournament)}
              </div>
              <div class="tab-pane fade" id="matches" role="tabpanel">
                ${renderMatches(matches, tournament)}
              </div>
              <div class="tab-pane fade" id="participants" role="tabpanel">
                ${renderParticipants(tournament.participants)}
                ${token && tournament.organizer && tournament.organizer._id === user.id && tournament.status === 'registration' ? `
                  <div class="mt-3">
                    <button id="add-players-btn" class="btn btn-primary">Add Players</button>
                  </div>
                ` : ''}
              </div>
            </div>
          </div>
        </div>
      `;
      
      document.getElementById('tournament-details').innerHTML = html;
      
      // Add event listeners for actions
      if (token) {
        const registerBtn = document.getElementById('register-btn');
        if (registerBtn) {
          registerBtn.addEventListener('click', registerForTournament);
        }
        
        const deleteBtn = document.getElementById('delete-btn');
        if (deleteBtn) {
          deleteBtn.addEventListener('click', deleteTournament);
        }
        
        const startTournamentBtn = document.getElementById('start-tournament-btn');
        if (startTournamentBtn) {
          startTournamentBtn.addEventListener('click', startTournament);
        }
        
        const editTournamentBtn = document.getElementById('edit-tournament-btn');
        if (editTournamentBtn) {
          editTournamentBtn.addEventListener('click', function() {
            // Store the tournament ID in localStorage before navigation
            localStorage.setItem('currentTournamentId', tournamentId);
            // Navigate to the edit page with auth token
            window.location.href = `/tournament-edit.html?id=${tournamentId}`;
          });
        }
        
        const addPlayersBtn = document.getElementById('add-players-btn');
        if (addPlayersBtn) {
          addPlayersBtn.addEventListener('click', () => {
            window.location.href = `/player-registration-google.html?tournamentId=${tournamentId}`;
          });
        }
        
        // Add event listeners for result buttons
        const resultButtons = document.querySelectorAll('.btn-result');
        resultButtons.forEach(button => {
          button.addEventListener('click', function() {
            const matchId = this.getAttribute('data-match-id');
            const result = this.getAttribute('data-result');
            recordMatchResult(matchId, result);
          });
        });
        
        // Add generate pairings button for tournament organizer or owner
        if (isOrganizer || isOwner || isTournamentCreatedByOwner) {
          const matchesTab = document.getElementById('matches');
          if (matchesTab) {
            const generatePairingsBtn = document.createElement('button');
            generatePairingsBtn.className = 'btn btn-gradient-primary mt-3';
            
            // Check if this is the last round
            const isLastRound = tournament.currentRound >= tournament.rounds;
            
            // Set button text based on whether this is the last round
            generatePairingsBtn.textContent = isLastRound ? 'Finish Tournament' : 'Generate Next Round Pairings';
            
            // Add appropriate event listener
            generatePairingsBtn.addEventListener('click', isLastRound ? finishTournament : generatePairings);
            
            matchesTab.prepend(generatePairingsBtn);
          }
        }
      }
    }
    
    // Helper function to get pairing system name in a user-friendly format
    function getPairingSystemName(algorithm) {
      const pairingSystemNames = {
        'swiss': 'Swiss System',
        'doubleSwiss': 'Double Swiss System',
        'roundRobin': 'Round Robin',
        'knockout': 'Knockout (Single Elimination)',
        'scheveningen': 'Scheveningen System',
        'monrad': 'Monrad System (Danish System)',
        'random': 'Random Pairing',
        'accelerated': 'Accelerated Pairing'
      };
      return pairingSystemNames[algorithm] || algorithm;
    }
    
    // Helper function to get pairing system description
    function getPairingSystemDescription(algorithm) {
      const pairingSystemDescriptions = {
        'swiss': 'Players meet opponents with similar scores. No player will face the same opponent twice. Ideal for tournaments with large number of players but limited rounds.',
        'doubleSwiss': 'Similar to Swiss, but allows up to two matches between the same players. Good for smaller tournaments where variety in opponents is limited.',
        'roundRobin': 'Each participant plays against every other participant. Provides the most fair comparison as all players face the same opponents.',
        'knockout': 'Players are eliminated after losing a match. Ensures a clear winner through direct competition, but provides fewer games for eliminated players.',
        'scheveningen': 'Team-based competition where each player from one team faces every player from the opposing team. Excellent for team vs team competitions.',
        'monrad': 'Modified Swiss system (Danish System) where leaders may intentionally face trailing players. Creates more diverse matchups while maintaining competitive balance.',
        'random': 'Opponents assigned randomly without considering scores or rankings. Can be used for casual events or as a fallback when other systems fail.',
        'accelerated': 'Modified Swiss designed to speed up the formation of top-tier matchups by artificially boosting top seeds\' scores in early rounds.'
      };
      return pairingSystemDescriptions[algorithm] || 'Custom pairing system';
    }
    
    // Render standings table
    function renderStandings(tournament) {
      if (!tournament.participants || tournament.participants.length === 0) {
        return `<div class="alert alert-info">No participants registered yet.</div>`;
      }
      
      // Sort participants by score (descending) and then by tieBreak (descending)
      const sortedParticipants = [...tournament.participants].sort((a, b) => {
        if (b.score !== a.score) {
          return b.score - a.score;
        }
        // Use Buchholz Cut 1 as the first tiebreaker
        if (b.buchholzCut1 !== a.buchholzCut1) {
          return b.buchholzCut1 - a.buchholzCut1;
        }
        // Use Buchholz as the second tiebreaker
        if (b.buchholz !== a.buchholz) {
          return b.buchholz - a.buchholz;
        }
        // Use Sonneborn-Berger as the third tiebreaker
        if (b.sonnebornBerger !== a.sonnebornBerger) {
          return b.sonnebornBerger - a.sonnebornBerger;
        }
        // Use Progressive Score as the fourth tiebreaker
        if (b.progressiveScore !== a.progressiveScore) {
          return b.progressiveScore - a.progressiveScore;
        }
        // Use number of wins as the fifth tiebreaker
        if (b.wins !== a.wins) {
          return b.wins - a.wins;
        }
        // Use number of black wins as the sixth tiebreaker
        return b.blackWins - a.blackWins;
      });
      
      let html = '';
      
      // If tournament is completed, show a summary with winner announcement
      if (tournament.status === 'completed') {
        const winner = sortedParticipants[0]?.player;
        const runnerUp = sortedParticipants[1]?.player;
        const thirdPlace = sortedParticipants[2]?.player;
        
        if (winner) {
          html += `
            <div class="card mb-4">
              <div class="card-header bg-success text-white">
                <h3 class="card-title mb-0">Tournament Results</h3>
              </div>
              <div class="card-body">
                <div class="text-center mb-4">
                  <h2>🏆 Tournament Champion 🏆</h2>
                  <h3>${winner.firstName} ${winner.lastName}</h3>
                  <p class="lead">Score: ${sortedParticipants[0].score.toFixed(1)} points</p>
                </div>
                
                <div class="row">
                  ${runnerUp ? `
                    <div class="col-md-6">
                      <div class="card mb-3">
                        <div class="card-header bg-secondary text-white">
                          <h5 class="card-title mb-0">🥈 Runner-up</h5>
                        </div>
                        <div class="card-body">
                          <h5>${runnerUp.firstName} ${runnerUp.lastName}</h5>
                          <p>Score: ${sortedParticipants[1].score.toFixed(1)} points</p>
                        </div>
                      </div>
                    </div>
                  ` : ''}
                  
                  ${thirdPlace ? `
                    <div class="col-md-6">
                      <div class="card mb-3">
                        <div class="card-header bg-secondary text-white">
                          <h5 class="card-title mb-0">🥉 Third Place</h5>
                        </div>
                        <div class="card-body">
                          <h5>${thirdPlace.firstName} ${thirdPlace.lastName}</h5>
                          <p>Score: ${sortedParticipants[2].score.toFixed(1)} points</p>
                        </div>
                      </div>
                    </div>
                  ` : ''}
                </div>
                
                <div class="text-center mt-3">
                  <h4>Tournament Summary</h4>
                  <p>
                    <strong>Total Rounds:</strong> ${tournament.rounds}<br>
                    <strong>Total Participants:</strong> ${tournament.participants.length}<br>
                    <strong>Tournament Format:</strong> ${tournament.format}<br>
                    <strong>Time Control:</strong> ${tournament.timeControl || 'Not specified'}<br>
                    <strong>Location:</strong> ${tournament.location}<br>
                    <strong>Dates:</strong> ${new Date(tournament.startDate).toLocaleDateString()} - ${new Date(tournament.endDate).toLocaleDateString()}
                  </p>
                </div>
                
                <div class="text-center mt-4">
                  <h5>Download Tournament Results</h5>
                  <div class="d-flex justify-content-center gap-3 mt-3">
                    <button class="btn btn-success" onclick="downloadStandings('excel')">
                      <i class="bi bi-file-earmark-excel me-2"></i> Excel Format
                    </button>
                    <button class="btn btn-primary" onclick="downloadStandings('word')">
                      <i class="bi bi-file-earmark-word me-2"></i> Word Format
                    </button>
                  </div>
                  <p class="text-muted mt-2 small">Download the final standings and tournament results for your records.</p>
                </div>
              </div>
            </div>
          `;
        }
      }
      
      // Add a legend for the tiebreak abbreviations
      html += `
        <div class="mb-3">
          <h5>Standings</h5>
          <div class="small text-muted">
            <strong>Tiebreak Legend:</strong><br>
            Pts: Points<br>
            BHC1: Buchholz Cut 1 (sum of opponents' scores, excluding the lowest)<br>
            BH: Buchholz (sum of opponents' scores)<br>
            SB: Sonneborn-Berger (sum of scores of defeated opponents + half scores of drawn opponents)<br>
            PS: Progressive Score (cumulative score after each round)<br>
            DE: Direct Encounter (head-to-head result)<br>
            WIN: Number of Wins<br>
            BWG: Number of Games Won with Black
          </div>
        </div>
        <div class="table-responsive">
          <table class="table table-striped">
            <thead>
              <tr>
                <th>#</th>
                <th>Player</th>
                <th>Rating</th>
                <th>Pts</th>
                <th>BHC1</th>
                <th>BH</th>
                <th>SB</th>
                <th>PS</th>
                <th>WIN</th>
                <th>BWG</th>
              </tr>
            </thead>
            <tbody>
      `;
      
      sortedParticipants.forEach((participant, index) => {
        const player = participant.player;
        if (!player) return;
        
        html += `
          <tr>
            <td>${index + 1}</td>
            <td>${player.firstName || ''} ${player.lastName || ''}</td>
            <td>${player.chessRating || 'N/A'}</td>
            <td><strong>${participant.score.toFixed(1)}</strong></td>
            <td>${participant.buchholzCut1?.toFixed(1) || '0.0'}</td>
            <td>${participant.buchholz?.toFixed(1) || '0.0'}</td>
            <td>${participant.sonnebornBerger?.toFixed(1) || '0.0'}</td>
            <td>${participant.progressiveScore?.toFixed(1) || '0.0'}</td>
            <td>${participant.wins || '0'}</td>
            <td>${participant.blackWins || '0'}</td>
          </tr>
        `;
      });
      
      html += `
            </tbody>
          </table>
        </div>
      `;
      
      return html;
    }
    
    // Render matches table
    function renderMatches(matches, tournament) {
      if (!matches || matches.length === 0) {
        return '<div class="alert alert-info">No matches have been generated yet.</div>';
      }
      
      // Group matches by round
      const matchesByRound = {};
      matches.forEach(match => {
        if (!matchesByRound[match.round]) {
          matchesByRound[match.round] = [];
        }
        matchesByRound[match.round].push(match);
      });
      
      // Initialize pending results object if it doesn't exist
      if (!window.pendingResults) {
        window.pendingResults = {};
      }
      
      // Toggle a result for pending submission
      window.togglePendingResult = function(matchId, result) {
        const buttons = document.querySelectorAll(`[data-match-id="${matchId}"]`);
        
        if (window.pendingResults[matchId] === result) {
          // If same result is clicked again, unselect it
          delete window.pendingResults[matchId];
          buttons.forEach(btn => {
            if (btn.getAttribute('data-result') === result) {
              btn.classList.remove('active');
              btn.classList.add('btn-outline-primary');
              btn.classList.remove('btn-primary');
            }
          });
        } else {
          // Otherwise update the result
          window.pendingResults[matchId] = result;
          
          // Update button states
          buttons.forEach(btn => {
            if (btn.getAttribute('data-result') === result) {
              btn.classList.add('active');
              btn.classList.remove('btn-outline-primary');
              btn.classList.add('btn-primary');
            } else {
              btn.classList.remove('active');
              btn.classList.add('btn-outline-primary');
              btn.classList.remove('btn-primary');
            }
          });
        }
        
        // Update the submit button visibility
        updateSubmitButton();
      };
      
      // Submit all pending results
      window.submitAllResults = async function(event) {
        // Get the clicked button
        const clickedBtn = event ? event.target : document.querySelector('.submit-results-btn');
        if (!clickedBtn) return;
        
        // Disable the button and show loading state
        clickedBtn.disabled = true;
        clickedBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Submitting...';
        
        // Also disable all other submit buttons to prevent double submission
        document.querySelectorAll('.submit-results-btn').forEach(btn => {
          if (btn !== clickedBtn) {
            btn.disabled = true;
          }
        });
        
        const errorMessages = [];
        const totalResults = Object.keys(window.pendingResults).length;
        let completedCount = 0;
        
        // Process each result one by one
        for (const [matchId, result] of Object.entries(window.pendingResults)) {
          try {
            const response = await fetch('/api/tournaments/matches/' + matchId, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + token
              },
              body: JSON.stringify({ result })
            });
            
            const data = await response.json();
            
            if (!response.ok) {
              errorMessages.push('Match ' + matchId + ': ' + (data.error || 'Failed to record match result'));
            }
            
            completedCount++;
            clickedBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Submitting ' + completedCount + '/' + totalResults + '...';
            
          } catch (error) {
            errorMessages.push('Match ' + matchId + ': ' + error.message);
            completedCount++;
          }
        }
        
        // Reset all submit buttons
        document.querySelectorAll('.submit-results-btn').forEach(btn => {
          btn.disabled = false;
          btn.innerHTML = 'Submit Results';
        });
        
        // Clear the pending results
        window.pendingResults = {};
        updateSubmitButton();
        
        // Show results message
        if (errorMessages.length === 0) {
          showToast('All match results submitted successfully!', 'success');
          // Refresh the tournament details to show the updated standings
          await fetchTournamentDetails();
        } else {
          showToast('Some results could not be submitted: ' + errorMessages.length + ' errors', 'danger');
          console.error('Errors submitting results:', errorMessages);
        }
      };
      
      let html = '';
      
      // Render matches by round
      Object.keys(matchesByRound).sort((a, b) => a - b).forEach(round => {
        // Start round container
        html += '<div class="round-container">';
        html += '<div class="round-header">';
        html += '<h4 class="m-0">Round ' + round + '</h4>';
        html += '</div>';
        
        html += '<div class="table-responsive">';
        html += '<table class="table table-striped">';
        html += '<thead><tr><th>Board</th><th>White</th><th>Black</th><th>Result</th></tr></thead>';
        html += '<tbody>';
        
        matchesByRound[round].forEach(match => {
          let result = 'Not played';
          if (match.result) {
            switch (match.result) {
              case 'white':
              case '1-0':
                result = '1-0';
                break;
              case 'black':
              case '0-1':
                result = '0-1';
                break;
              case 'draw':
              case '1/2-1/2':
                result = '½-½';
                break;
              case 'BYE':
                result = 'BYE (1 point)';
                break;
            }
          }
          
          // Add result entry buttons for tournament organizers
          const isOrganizer = token && tournament && tournament.organizer && tournament.organizer._id === user.id;
          let resultButtons = '';
          
          if (isOrganizer && !match.isBye && (match.result === '*' || !match.result)) {
            resultButtons = '<div class="btn-group btn-group-sm mt-2">';
            resultButtons += '<button class="btn btn-outline-primary" onclick="togglePendingResult(\'' + match._id + '\', \'white\')" data-match-id="' + match._id + '" data-result="white">1-0</button>';
            resultButtons += '<button class="btn btn-outline-primary" onclick="togglePendingResult(\'' + match._id + '\', \'draw\')" data-match-id="' + match._id + '" data-result="draw">½-½</button>';
            resultButtons += '<button class="btn btn-outline-primary" onclick="togglePendingResult(\'' + match._id + '\', \'black\')" data-match-id="' + match._id + '" data-result="black">0-1</button>';
            resultButtons += '</div>';
          }
          
          // Render the match row
          html += '<tr>';
          html += '<td>' + (match.board || '-') + '</td>';
          
          // White player
          html += '<td>';
          if (match.whitePlayer) {
            html += match.whitePlayer.firstName + ' ' + match.whitePlayer.lastName;
            if (match.whitePlayer.chessRating) {
              html += ' <span class="text-muted">(' + match.whitePlayer.chessRating + ')</span>';
            }
          } else {
            html += 'BYE';
          }
          html += '</td>';
          
          // Black player
          html += '<td>';
          if (match.blackPlayer) {
            html += match.blackPlayer.firstName + ' ' + match.blackPlayer.lastName;
            if (match.blackPlayer.chessRating) {
              html += ' <span class="text-muted">(' + match.blackPlayer.chessRating + ')</span>';
            }
          } else {
            html += match.isBye ? 'BYE' : 'N/A';
          }
          html += '</td>';
          
          // Result
          html += '<td>' + result + resultButtons + '</td>';
          html += '</tr>';
        });
        
        html += '</tbody></table></div>';
        
        // Add the round footer with submit button
        html += '<div class="round-footer">';
        html += '<button class="btn btn-gradient-success submit-results-btn" style="display: none;" onclick="submitAllResults(event)">Submit Results</button>';
        html += '</div>';
        
        html += '</div>'; // Close round container
      });
      
      return html;
    }
    
    // Render participants list
    function renderParticipants(participants) {
      if (!participants || participants.length === 0) {
        return '<div class="alert alert-info">No participants registered yet.</div>';
      }
      
      let html = '';
      
      // Add a legend for the tiebreak abbreviations
      html += `
        <div class="mb-3">
          <h5>Participants</h5>
          <div class="small text-muted">
            
          
            
            
          </div>
        </div>
        <div class="table-responsive">
          <table class="table table-striped">
            <thead>
              <tr>
                <th>#</th>
                <th>Player</th>
                <th>Rating</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody>
      `;
      
      participants.forEach((participant, index) => {
        const player = participant.player;
        if (!player) return;
        
        let status = '';
        if (participant.confirmed) {
          status = '<span class="badge bg-success">Confirmed</span>';
        } else {
          status = '<span class="badge bg-warning text-dark">Pending</span>';
        }
        
        if (participant.paid) {
          status += ' <span class="badge bg-info">Paid</span>';
        }
        
        html += `
          <tr>
            <td>${index + 1}</td>
            <td>${player.firstName} ${player.lastName}</td>
            <td>${player.chessRating || 'N/A'}</td>
            <td>${status}</td>
          </tr>
        `;
      });
      
      html += `
            </tbody>
          </table>
        </div>
      `;
      
      return html;
    }
    // Function for button reset (used in other functions)
    function resetButton(button, originalText) {
      button.disabled = false;
      button.textContent = originalText;
    }
    
    // Delete tournament
    async function deleteTournament() {
      // Show confirmation modal
      const confirmationModal = new bootstrap.Modal(document.getElementById('confirmationModal'));
      document.getElementById('confirmationModalLabel').textContent = 'Delete Tournament';
      document.getElementById('confirmationModalBody').textContent = 'Are you sure you want to delete this tournament? This action cannot be undone.';
      
      // Set up the confirm button action
      const confirmBtn = document.getElementById('confirmModalBtn');
      const originalBtnText = confirmBtn.textContent;
      
      // Remove any existing event listeners
      const newConfirmBtn = confirmBtn.cloneNode(true);
      confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
      
      newConfirmBtn.addEventListener('click', async function() {
        // Disable button and show loading state
        this.disabled = true;
        this.textContent = 'Deleting...';
      
        try {
          const response = await fetch(`/api/tournaments/${tournamentId}`, {
            method: 'DELETE',
            headers: {
              'Authorization': `Bearer ${token}`
            }
          });
          
          if (response.ok) {
            // Hide the modal
            confirmationModal.hide();
            
            // Store a flag in sessionStorage to show notification on the tournaments page
            sessionStorage.setItem('showDeletedNotification', 'true');
            
            // Redirect to tournaments page immediately
            window.location.href = '/tournaments';
          } else {
            const data = await response.json();
            throw new Error(data.error || 'Failed to delete tournament.');
          }
        } catch (error) {
          // Show error toast
          showToast(`Error: ${error.message}`, 'danger');
          
          // Reset button
          this.disabled = false;
          this.textContent = originalBtnText;
          
          // Hide the modal
          confirmationModal.hide();
        }
      });
      
      // Show the modal
      confirmationModal.show();
    }
    
    // Record match result
    async function recordMatchResult(matchId, result) {
      try {
        // Find all buttons for this match and disable them
        const buttons = document.querySelectorAll(`[data-match-id="${matchId}"]`);
        buttons.forEach(btn => {
          btn.disabled = true;
          if (btn.getAttribute('data-result') === result) {
            btn.textContent = 'Saving...';
          }
        });
        
        console.log(`Recording result ${result} for match ${matchId}`);
        
        const response = await fetch(`/api/tournaments/matches/${matchId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({ result })
        });
        
        if (!response.ok) {
          const errorData = await response.json();
          console.error('Failed to record match result:', errorData);
          throw new Error(errorData.error || 'Failed to record match result');
        }
        
        const data = await response.json();
        console.log('Match result recorded successfully:', data);
        
        if (data.success) {
          // Update the match result in the UI without reloading the page
          const matchRow = buttons[0].closest('tr');
          if (matchRow) {
            const resultCell = matchRow.querySelector('td:nth-child(4)');
            if (resultCell) {
              let resultText;
              switch (result) {
                case 'white':
                  resultText = '1-0';
                  break;
                case 'black':
                  resultText = '0-1';
                  break;
                case 'draw':
                  resultText = '½-½';
                  break;
                default:
                  resultText = 'Not played';
              }
              
              // Update the result text
              resultCell.innerHTML = resultText;
              
              // Remove the result buttons
              const buttonsDiv = resultCell.querySelector('.btn-group');
              if (buttonsDiv) {
                buttonsDiv.remove();
              }
            }
          }
          
          // Update the standings if the tournament data is included in the response
          if (data.data && data.data.tournament) {
            console.log('Updating standings with new tournament data:', data.data.tournament);
            
            // Log participant scores for debugging
            if (data.data.tournament.participants) {
              console.log('Participant scores:');
              data.data.tournament.participants.forEach(p => {
                if (p.player) {
                  console.log(`${p.player.firstName} ${p.player.lastName}: Score=${p.score}, BHC1=${p.buchholzCut1}, BH=${p.buchholz}, SB=${p.sonnebornBerger}, PS=${p.progressiveScore}, Wins=${p.wins}, BlackWins=${p.blackWins}`);
                }
              });
            }
            
            const standingsTab = document.getElementById('standings');
            if (standingsTab) {
              standingsTab.innerHTML = renderStandings(data.data.tournament);
            }
          } else {
            console.error('Tournament data not included in response');
          }
          
          // Show a success message
          const alertDiv = document.createElement('div');
          alertDiv.className = 'alert alert-success alert-dismissible fade show mt-3';
          alertDiv.innerHTML = `
            Match result recorded successfully!
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
          `;
          
          // Insert the alert before the matches table
          const matchesTab = document.getElementById('matches');
          if (matchesTab) {
            matchesTab.prepend(alertDiv);
            
            // Auto-dismiss after 3 seconds
            setTimeout(() => {
              const bsAlert = new bootstrap.Alert(alertDiv);
              bsAlert.close();
            }, 3000);
          }
        } else {
          alert(data.error || 'Failed to record match result.');
        }
      } catch (error) {
        console.error('Error recording match result:', error);
        alert(`Error: ${error.message}`);
      } finally {
        // Re-enable all buttons for this match
        const buttons = document.querySelectorAll(`[data-match-id="${matchId}"]`);
        buttons.forEach(btn => {
          btn.disabled = false;
          const resultType = btn.getAttribute('data-result');
          if (resultType === 'white') {
            btn.textContent = '1-0';
          } else if (resultType === 'black') {
            btn.textContent = '0-1';
          } else if (resultType === 'draw') {
            btn.textContent = '½-½';
          }
        });
      }
    }
    
    // Generate pairings for next round
    async function generatePairings() {
      // Show confirmation modal
      const confirmationModal = new bootstrap.Modal(document.getElementById('confirmationModal'));
      document.getElementById('confirmationModalLabel').textContent = 'Generate Pairings';
      document.getElementById('confirmationModalBody').textContent = 'Are you sure you want to generate pairings for the next round? All current round matches must be completed.';
      
      // Set up the confirm button action
      const confirmBtn = document.getElementById('confirmModalBtn');
      const originalBtnText = confirmBtn.textContent;
      
      // Remove any existing event listeners
      const newConfirmBtn = confirmBtn.cloneNode(true);
      confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
      
      newConfirmBtn.addEventListener('click', async function() {
        // Disable button and show loading state
        this.disabled = true;
        this.textContent = 'Generating...';
        
        // Hide the modal
        confirmationModal.hide();
        
        const generateBtn = document.querySelector('#matches button.btn-gradient-primary');
        if (generateBtn) {
          generateBtn.disabled = true;
          generateBtn.textContent = 'Generating pairings...';
        }
        
        try {
          console.log('Generating pairings for tournament:', tournamentId);
          
          const response = await fetch(`/api/tournaments/${tournamentId}/pairings`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            }
          });
          
          if (!response.ok) {
            const errorData = await response.json();
            console.error('Failed to generate pairings:', errorData);
            throw new Error(errorData.error || 'Failed to generate pairings');
          }
          
          const data = await response.json();
          console.log('Pairings generated successfully:', data);
          
          if (data.success) {
            // Set a flag in sessionStorage to show a success message after the page loads
            sessionStorage.setItem('showPairingsGeneratedNotification', 'true');
            
            // Reload the page immediately
            window.location.reload();
          } else {
            throw new Error(data.error || 'Failed to generate pairings.');
          }
        } catch (error) {
          console.error('Error generating pairings:', error);
          
          // Show error in modal dialog
          const pairingErrorModal = document.getElementById('pairingErrorModal');
          const errorMessage = document.getElementById('pairingErrorMessage');
          
          // Set the error message
          errorMessage.textContent = error.message;
          
          // Initialize the modal
          const modal = new bootstrap.Modal(pairingErrorModal);
          
          // Show the modal
          modal.show();
          
          // Make the entire document dismissible when clicked
          const handleDocumentClick = (event) => {
            // Check if the click is outside the modal content
            if (!event.target.closest('.modal-content')) {
              modal.hide();
              document.removeEventListener('click', handleDocumentClick);
            }
          };
          
          // Add click event listener after a short delay to prevent immediate dismissal
          setTimeout(() => {
            document.addEventListener('click', handleDocumentClick);
          }, 500);
          
          // Reset buttons
          if (generateBtn) {
            generateBtn.disabled = false;
            generateBtn.textContent = 'Generate Next Round Pairings';
          }
          this.disabled = false;
          this.textContent = originalBtnText;
        }
      });
      
      // Show the modal
      confirmationModal.show();
    }
    
    // Start tournament and generate first round pairings
    async function startTournament() {
      // Show confirmation modal
      const confirmationModal = new bootstrap.Modal(document.getElementById('confirmationModal'));
      document.getElementById('confirmationModalLabel').textContent = 'Start Tournament';
      document.getElementById('confirmationModalBody').textContent = 'Do you want to start this tournament? This will close registration and generate pairings for the first round.';
      
      // Set up the confirm button action
      const confirmBtn = document.getElementById('confirmModalBtn');
      const originalBtnText = confirmBtn.textContent;
      
      // Remove any existing event listeners
      const newConfirmBtn = confirmBtn.cloneNode(true);
      confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
      
      newConfirmBtn.addEventListener('click', async function() {
        // Disable button and show loading state
        this.disabled = true;
        this.textContent = 'Starting...';
        
        // Hide the modal
        confirmationModal.hide();
      
      const startBtn = document.getElementById('start-tournament-btn');
      startBtn.textContent = 'Starting tournament...';
      startBtn.disabled = true;
      
      try {
        console.log('Starting tournament:', tournamentId);
        console.log('User:', user);
        console.log('Token:', token ? 'Token exists' : 'No token');
        
        // First, update tournament status to 'active'
        const updateRequestData = {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({ 
            status: 'active',
            currentRound: 0
          })
        };
        
        console.log('Update request data:', JSON.stringify(updateRequestData));
        
        const updateResponse = await fetch(`/api/tournaments/${tournamentId}`, updateRequestData);
        
        console.log('Update response status:', updateResponse.status);
        
        if (!updateResponse.ok) {
          const errorData = await updateResponse.json();
          console.error('Failed to update tournament status:', errorData);
          throw new Error(errorData.error || 'Failed to update tournament status');
        }
        
        console.log('Tournament status updated to active');
        
        // Wait a moment to ensure the status update is processed
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Then generate pairings for the first round
        const pairingsRequestData = {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          }
        };
        
        console.log('Pairings request data:', JSON.stringify(pairingsRequestData));
        
        const pairingsResponse = await fetch(`/api/tournaments/${tournamentId}/pairings`, pairingsRequestData);
        
        console.log('Pairings response status:', pairingsResponse.status);
        
        if (!pairingsResponse.ok) {
          const errorData = await pairingsResponse.json();
          console.error('Failed to generate pairings:', errorData);
          throw new Error(errorData.error || 'Failed to generate pairings');
        }
        
        console.log('Pairings generated successfully');
        
          // Set a flag in sessionStorage to show a success message after the page loads
          sessionStorage.setItem('showTournamentStartedNotification', 'true');
        
          // Redirect immediately to show the updated tournament
        window.location.href = `/tournament-details.html?id=${tournamentId}`;
      } catch (error) {
        console.error('Error starting tournament:', error);
          
          // Show error toast
          showToast(`Error: ${error.message}`, 'danger');
          
          // Reset buttons
        startBtn.textContent = 'Start Tournament';
        startBtn.disabled = false;
          this.disabled = false;
          this.textContent = originalBtnText;
        }
      });
      
      // Show the modal
      confirmationModal.show();
    }
    
    // Finish tournament and mark it as completed
    async function finishTournament() {
      console.log('finishTournament function called');
      
      // Show confirmation modal
      const confirmationModal = new bootstrap.Modal(document.getElementById('confirmationModal'));
      document.getElementById('confirmationModalLabel').textContent = 'Finish Tournament';
      document.getElementById('confirmationModalBody').textContent = 'Are you sure you want to finish this tournament? This will mark the tournament as completed and finalize the standings.';
      
      // Set up the confirm button action
      const confirmBtn = document.getElementById('confirmModalBtn');
      const originalBtnText = confirmBtn.textContent;
      
      // Remove any existing event listeners
      const newConfirmBtn = confirmBtn.cloneNode(true);
      confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
      
      newConfirmBtn.addEventListener('click', async function() {
        try {
          console.log('Confirm button clicked');
          
          // Disable button and show loading state
          this.disabled = true;
          this.textContent = 'Finishing...';
          
          // Hide the modal
          confirmationModal.hide();
          
          // Find and disable the finish button
          const finishBtn = document.querySelector('#matches button.btn-gradient-primary');
          if (finishBtn) {
            console.log('Found finish button, disabling it');
            finishBtn.disabled = true;
            finishBtn.textContent = 'Finishing tournament...';
          } else {
            console.log('Finish button not found');
          }
          
          console.log('Finishing tournament:', tournamentId);
          
          // Show a toast notification that we're processing
          showToast('Finishing tournament...', 'info');
          
          // Update tournament status to 'completed'
          console.log('Sending PUT request to update tournament status');
          
          // Create the request data
          const requestData = {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({ 
              status: 'completed'
            })
          };
          
          console.log('Request data:', JSON.stringify(requestData));
          
          // Send the request
          const response = await fetch(`/api/tournaments/${tournamentId}`, requestData);
          
          console.log('Response status:', response.status, response.statusText);
          
          // Handle non-OK responses
          if (!response.ok) {
            let errorMessage = `Server returned ${response.status}: ${response.statusText}`;
            
            try {
              const errorData = await response.json();
              console.error('Error data:', errorData);
              if (errorData && errorData.error) {
                errorMessage = errorData.error;
              }
            } catch (parseError) {
              console.error('Could not parse error response:', parseError);
            }
            
            throw new Error(errorMessage);
          }
          
          // Process successful response
          console.log('Tournament status updated successfully');
          
          // Set a flag in sessionStorage to show a success message after the page loads
          sessionStorage.setItem('showTournamentFinishedNotification', 'true');
          
          // Show success message
          showToast('Tournament completed successfully! Redirecting to standings...', 'success');
          
          // Update the UI to reflect the completed status without requiring a refresh
          try {
            console.log('Updating UI to reflect completed status');
            
            // Update the status badge
            const statusBadge = document.querySelector('.badge');
            if (statusBadge) {
              statusBadge.className = 'badge bg-secondary';
              statusBadge.textContent = 'Completed';
            }
            
            // Remove the finish tournament button
            if (finishBtn) {
              finishBtn.remove();
            }
            
            // Activate the standings tab
            const standingsTab = document.getElementById('standings-tab');
            if (standingsTab) {
              const tab = new bootstrap.Tab(standingsTab);
              tab.show();
            }
            
            // Fetch the updated tournament data to show the final standings
            const updatedData = await fetchTournamentDetails();
            if (updatedData) {
              const standingsPane = document.getElementById('standings');
              if (standingsPane) {
                standingsPane.innerHTML = renderStandings(updatedData.tournament);
              }
            }
            
            // Show a success message
            showToast('Tournament completed successfully! Viewing final standings.', 'success');
          } catch (uiError) {
            console.error('Error updating UI:', uiError);
          }
          
          // Force a hard reload of the page with the standings tab active
          console.log('Forcing page reload to standings tab');
          
          try {
            // Use a short delay before redirecting to ensure the UI updates are visible
            setTimeout(() => {
              window.location.replace(`/tournament-details.html?id=${tournamentId}&reload=${Date.now()}#standings`);
            }, 1000);
            
            // Set a fallback in case the redirect doesn't work
            setTimeout(() => {
              console.log('Fallback: Checking if redirect worked');
              // If we're still on the page after 3 seconds, try a different approach
              showToast('Redirect may have failed. Please click the "Refresh" button below.', 'warning');
              
              // Create a refresh button
              const matchesTab = document.getElementById('matches');
              if (matchesTab) {
                const refreshBtn = document.createElement('button');
                refreshBtn.className = 'btn btn-warning mt-3';
                refreshBtn.textContent = 'Refresh to See Results';
                refreshBtn.addEventListener('click', () => {
                  window.location.href = `/tournament-details.html?id=${tournamentId}#standings`;
                });
                matchesTab.prepend(refreshBtn);
              }
            }, 3000);
          } catch (redirectError) {
            console.error('Error during redirect:', redirectError);
            // If redirect fails, show a message and provide a manual refresh button
            showToast('Unable to redirect automatically. Please refresh the page manually.', 'warning');
          }
          
        } catch (error) {
          console.error('Error finishing tournament:', error);
          
          // Show error toast
          showToast(`Error: ${error.message}`, 'danger');
          
          // Reset buttons
          if (finishBtn) {
            finishBtn.disabled = false;
            finishBtn.textContent = 'Finish Tournament';
          }
          
          this.disabled = false;
          this.textContent = originalBtnText;
        }
      });
      
      // Show the modal
      confirmationModal.show();
    }
    
    // Download tournament standings in Excel or Word format
    function downloadStandings(format) {
      // Get tournament data from the page
      const tournamentName = document.querySelector('h1').textContent;
      const tournamentDate = new Date().toLocaleDateString();
      
      // Get additional tournament info
      const tournamentInfo = {};
      document.querySelectorAll('.card-body p strong').forEach(el => {
        const key = el.textContent.replace(':', '').trim();
        const value = el.parentNode.textContent.replace(key + ':', '').trim();
        tournamentInfo[key] = value;
      });
      
      // Get winner information
      let winnerInfo = '';
      const winnerElement = document.querySelector('.card-body h3');
      if (winnerElement) {
        const winnerName = winnerElement.textContent;
        const winnerScore = document.querySelector('.card-body p.lead')?.textContent || '';
        winnerInfo = `Champion: ${winnerName}, ${winnerScore}`;
      }
      
      // Create a table with the standings data
      const table = document.querySelector('#standings table').cloneNode(true);
      
      if (format === 'excel') {
        // For Excel, we'll create a CSV file
        let csv = `Tournament: ${tournamentName}\n`;
        csv += `Date: ${tournamentDate}\n`;
        csv += `Location: ${tournamentInfo['Location'] || 'N/A'}\n`;
        csv += `Format: ${tournamentInfo['Format'] || 'N/A'}\n`;
        csv += `Rounds: ${tournamentInfo['Rounds'] || 'N/A'}\n`;
        csv += `Time Control: ${tournamentInfo['Time Control'] || 'N/A'}\n`;
        csv += `Participants: ${tournamentInfo['Participants'] || 'N/A'}\n`;
        if (winnerInfo) {
          csv += `${winnerInfo}\n`;
        }
        csv += '\n';
        
        // Add headers
        const headers = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim());
        csv += headers.join(',') + '\n';
        
        // Add rows
        const rows = table.querySelectorAll('tbody tr');
        rows.forEach(row => {
          const cells = Array.from(row.querySelectorAll('td')).map(td => {
            // Wrap text with quotes if it contains commas
            let text = td.textContent.trim();
            if (text.includes(',')) {
              text = `"${text}"`;
            }
            return text;
          });
          csv += cells.join(',') + '\n';
        });
        
        // Create a Blob and download link
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.setAttribute('href', url);
        link.setAttribute('download', `${tournamentName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_standings.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        showToast('Standings downloaded as Excel (CSV) file', 'success');
      } else if (format === 'word') {
        // For Word, we'll create an HTML file that can be opened in Word
        let html = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="UTF-8">
            <title>${tournamentName} - Standings</title>
            <style>
              body { font-family: Arial, sans-serif; margin: 20px; }
              h1, h2, h3 { text-align: center; }
              .tournament-info { margin: 20px auto; max-width: 600px; }
              .tournament-info p { margin: 5px 0; }
              table { width: 100%; border-collapse: collapse; margin: 20px 0; }
              th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
              th { background-color: #f2f2f2; font-weight: bold; }
              tr:nth-child(even) { background-color: #f9f9f9; }
              .winner { font-weight: bold; color: #006400; }
              .footer { margin-top: 30px; text-align: center; font-size: 12px; color: #666; }
            </style>
          </head>
          <body>
            <h1>${tournamentName}</h1>
            <h2>Final Standings</h2>
            
            <div class="tournament-info">
              <p><strong>Date:</strong> ${tournamentDate}</p>
              <p><strong>Location:</strong> ${tournamentInfo['Location'] || 'N/A'}</p>
              <p><strong>Format:</strong> ${tournamentInfo['Format'] || 'N/A'}</p>
              <p><strong>Rounds:</strong> ${tournamentInfo['Rounds'] || 'N/A'}</p>
              <p><strong>Time Control:</strong> ${tournamentInfo['Time Control'] || 'N/A'}</p>
              <p><strong>Participants:</strong> ${tournamentInfo['Participants'] || 'N/A'}</p>
              ${winnerInfo ? `<p class="winner">${winnerInfo}</p>` : ''}
            </div>
            
            <table>
              <thead>
                <tr>
                  ${Array.from(table.querySelectorAll('thead th')).map(th => `<th>${th.textContent.trim()}</th>`).join('')}
                </tr>
              </thead>
              <tbody>
                ${Array.from(table.querySelectorAll('tbody tr')).map(row => `
                  <tr>
                    ${Array.from(row.querySelectorAll('td')).map(td => `<td>${td.textContent.trim()}</td>`).join('')}
                  </tr>
                `).join('')}
              </tbody>
            </table>
            
            <div class="footer">
              <p>Generated by Chess Tournament Manager on ${new Date().toLocaleString()}</p>
            </div>
          </body>
          </html>
        `;
        
        // Create a Blob and download link
        const blob = new Blob([html], { type: 'application/msword;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.setAttribute('href', url);
        link.setAttribute('download', `${tournamentName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_standings.doc`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        showToast('Standings downloaded as Word document', 'success');
      }
    }
    
    // Render Google Sheets tab
    function renderGoogleSheets(tournament, isOrganizer) {
      // If not organizer, show limited view
      if (!isOrganizer) {
        if (tournament.googleDocs && tournament.googleDocs.documentUrl) {
          return `
            <div class="card">
              <div class="card-header bg-primary text-white">
                <h3 class="card-title mb-0">Google Docs Registration</h3>
              </div>
              <div class="card-body">
                <p>This tournament has a Google Docs registration form. Click the link below to register:</p>
                <a href="${tournament.googleDocs.documentUrl}" target="_blank" class="btn btn-success">
                  <i class="bi bi-file-earmark-text"></i> Open Registration Form
                </a>
              </div>
          </div>
        `;
        } else if (tournament.googleSheets && tournament.googleSheets.spreadsheetUrl) {
          // Legacy support for Google Sheets
          return `
            <div class="card">
              <div class="card-header bg-primary text-white">
                <h3 class="card-title mb-0">Google Sheets Registration</h3>
              </div>
              <div class="card-body">
                <p>This tournament has a Google Sheets registration form. Click the link below to register:</p>
                <a href="${tournament.googleSheets.spreadsheetUrl}" target="_blank" class="btn btn-success">
                  <i class="bi bi-file-earmark-spreadsheet"></i> Open Registration Form
                </a>
              </div>
          </div>
        `;
        } else {
          return `
            <div class="alert alert-info">
              <i class="bi bi-info-circle"></i> No Google Docs registration form has been created for this tournament.
            </div>
          `;
        }
      }
      
      // Organizer view
      if (tournament.googleDocs && tournament.googleDocs.documentId) {
        // Doc exists
        const lastSyncDate = tournament.googleDocs.lastSyncDate ? 
          new Date(tournament.googleDocs.lastSyncDate).toLocaleString() : 'Never';
        
        return `
          <div class="card">
            <div class="card-header bg-primary text-white">
              <h3 class="card-title mb-0">Google Docs Integration</h3>
            </div>
            <div class="card-body">
              <div class="row">
                <div class="col-md-6">
                  <h4>Registration Form</h4>
                  <p>Share this Google Docs link with participants to register for the tournament:</p>
                  <div class="input-group mb-3">
                    <input type="text" class="form-control" value="${tournament.googleDocs.documentUrl}" readonly>
                    <button class="btn btn-outline-secondary" type="button" onclick="copyToClipboard('${tournament.googleDocs.documentUrl}')">
                      <i class="bi bi-clipboard"></i> Copy
                    </button>
                  </div>
                  <a href="${tournament.googleDocs.documentUrl}" target="_blank" class="btn btn-primary mb-3">
                    <i class="bi bi-file-earmark-text"></i> Open in Google Docs
                  </a>
                </div>
                <div class="col-md-6">
                  <h4>Sync Settings</h4>
                  <p>Last synced: ${lastSyncDate}</p>
                  <button id="sync-google-doc-btn" class="btn btn-success mb-3">
                    <i class="bi bi-arrow-repeat"></i> Sync Now
                  </button>
                  <button id="force-sync-google-doc-btn" class="btn btn-warning mb-3 ml-2">
                    <i class="bi bi-arrow-repeat"></i> Force Sync
                  </button>
                </div>
              </div>
            </div>
          </div>
        `;
      } else if (tournament.googleSheets && tournament.googleSheets.spreadsheetId) {
        // Legacy support for Google Sheets
        const lastSyncDate = tournament.googleSheets.lastSyncDate ? 
          new Date(tournament.googleSheets.lastSyncDate).toLocaleString() : 'Never';
        
        return `
          <div class="card">
            <div class="card-header bg-primary text-white">
              <h3 class="card-title mb-0">Google Sheets Integration (Legacy)</h3>
            </div>
            <div class="card-body">
              <div class="alert alert-warning">
                <i class="bi bi-exclamation-triangle"></i>
                This tournament is using the legacy Google Sheets integration. We recommend migrating to Google Docs for better features and support.
                <button id="migrate-to-docs-btn" class="btn btn-sm btn-warning mt-2">Migrate to Google Docs</button>
              </div>
              <div class="row">
                <div class="col-md-6">
                  <h4>Registration Form</h4>
                  <p>Share this Google Sheets link with participants to register for the tournament:</p>
                  <div class="input-group mb-3">
                    <input type="text" class="form-control" value="${tournament.googleSheets.spreadsheetUrl}" readonly>
                    <button class="btn btn-outline-secondary" type="button" onclick="copyToClipboard('${tournament.googleSheets.spreadsheetUrl}')">
                      <i class="bi bi-clipboard"></i> Copy
                    </button>
                  </div>
                  <a href="${tournament.googleSheets.spreadsheetUrl}" target="_blank" class="btn btn-primary mb-3">
                    <i class="bi bi-file-earmark-spreadsheet"></i> Open in Google Sheets
                  </a>
                </div>
                <div class="col-md-6">
                  <h4>Sync Settings</h4>
                  <p>Last synced: ${lastSyncDate}</p>
                  <button id="sync-google-sheet-btn" class="btn btn-success mb-3">
                    <i class="bi bi-arrow-repeat"></i> Sync Now
                  </button>
                </div>
              </div>
            </div>
          </div>
        `;
      } else {
        // No integration yet
        return `
          <div class="card">
            <div class="card-header bg-primary text-white">
              <h3 class="card-title mb-0">Google Docs Integration</h3>
            </div>
            <div class="card-body">
              <p>Create a Google Docs registration form for this tournament. Participants will be able to register by filling out the form.</p>
              <p>The system will automatically sync player data from the Google Doc to the tournament.</p>
              
              <button id="create-google-doc-btn" class="btn btn-primary">
                <i class="bi bi-file-earmark-text"></i> Create Google Doc
              </button>
            </div>
          </div>
        `;
      }
    }
    
    // Add event listeners for Google Sheets functionality
    function addGoogleSheetsEventListeners(tournament) {
      // Authenticate with Google button
      const authenticateGoogleBtn = document.getElementById('authenticateGoogle');
      if (authenticateGoogleBtn) {
        authenticateGoogleBtn.addEventListener('click', async function() {
          try {
            const response = await fetch('/api/google/auth-url', {
              headers: {
                'Authorization': `Bearer ${token}`
              }
            });
            
            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(errorData.error || 'Failed to get Google auth URL');
            }
            
            const data = await response.json();
            
            // Open Google auth URL in a new window
            window.open(data.data.authUrl, '_blank');
            
            // Show create sheet section
            document.getElementById('google-auth-section').style.display = 'none';
            document.getElementById('create-sheet-section').style.display = 'block';
          } catch (error) {
            console.error('Error authenticating with Google:', error);
            showToast('Failed to authenticate with Google: ' + error.message, 'danger');
          }
        });
      }
      
      // Create Google Sheet button
      const createGoogleSheetBtn = document.getElementById('createGoogleSheet');
      if (createGoogleSheetBtn) {
        createGoogleSheetBtn.addEventListener('click', async function() {
          try {
            const response = await fetch(`/api/google/tournaments/${tournamentId}/create-sheet`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
              }
            });
            
            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(errorData.error || 'Failed to create Google Sheet');
            }
            
            const data = await response.json();
            
            // Reload the page to show the new Google Sheet
            window.location.reload();
          } catch (error) {
            console.error('Error creating Google Sheet:', error);
            showToast('Failed to create Google Sheet: ' + error.message, 'danger');
          }
        });
      }
      
      // Sync Google Sheet button
      const syncGoogleSheetsBtn = document.getElementById('syncGoogleSheets');
      if (syncGoogleSheetsBtn) {
        syncGoogleSheetsBtn.addEventListener('click', async function() {
          try {
            const response = await fetch(`/api/google/tournaments/${tournamentId}/sync-sheet`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
              }
            });
            
            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(errorData.error || 'Failed to sync Google Sheet');
            }
            
            const data = await response.json();
            
            showToast(`Successfully synced ${data.count} players from Google Sheet`, 'success');
            
            // Reload the page to show the new players
            setTimeout(() => {
              window.location.reload();
            }, 2000);
          } catch (error) {
            console.error('Error syncing Google Sheet:', error);
            showToast('Failed to sync Google Sheet: ' + error.message, 'danger');
          }
        });
      }
      
      // Save Google Sheets settings button
      const saveGoogleSheetsSettingsBtn = document.getElementById('saveGoogleSheetsSettings');
      if (saveGoogleSheetsSettingsBtn) {
        saveGoogleSheetsSettingsBtn.addEventListener('click', async function() {
          try {
            const syncEnabled = document.getElementById('syncEnabledSwitch').checked;
            const syncFrequency = parseInt(document.getElementById('syncFrequency').value);
            
            const response = await fetch(`/api/google/tournaments/${tournamentId}/toggle-sync`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
              },
              body: JSON.stringify({
                syncEnabled,
                syncFrequency
              })
            });
            
            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(errorData.error || 'Failed to update Google Sheets settings');
            }
            
            showToast('Google Sheets settings updated successfully', 'success');
          } catch (error) {
            console.error('Error updating Google Sheets settings:', error);
            showToast('Failed to update Google Sheets settings: ' + error.message, 'danger');
          }
        });
      }
    }
    
    // Helper function to copy text to clipboard
    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(
        function() {
          showToast('Link copied to clipboard', 'success');
        }, 
        function(err) {
          console.error('Could not copy text: ', err);
          showToast('Failed to copy link', 'danger');
        }
      );
    }
    
    // Add event listeners for Google Docs functionality
    function addGoogleDocsEventListeners() {
      // Create Google Doc button
      const createGoogleDocBtn = document.getElementById('create-google-doc-btn');
      if (createGoogleDocBtn) {
        createGoogleDocBtn.addEventListener('click', async () => {
          try {
            createGoogleDocBtn.disabled = true;
            createGoogleDocBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Creating...';
            
            const response = await fetch(`/api/google/tournaments/${tournamentId}/create-doc`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
              }
            });
            
            const data = await response.json();
            
            if (!response.ok) {
              const errorData = data;
              throw new Error(errorData.error || 'Failed to create Google Doc');
            }
            
            showToast('Successfully created Google Doc', 'success');
            // Reload the page to show the new Google Doc
            loadTournamentDetails();
          } catch (error) {
            console.error('Error creating Google Doc:', error);
            showToast(`Error creating Google Doc: ${error.message}`, 'danger');
          } finally {
            createGoogleDocBtn.disabled = false;
            createGoogleDocBtn.innerHTML = '<i class="bi bi-file-earmark-text"></i> Create Google Doc';
          }
        });
      }
      
      // Sync Google Doc button
      const syncGoogleDocBtn = document.getElementById('sync-google-doc-btn');
      if (syncGoogleDocBtn) {
        syncGoogleDocBtn.addEventListener('click', () => syncGoogleDoc(false));
      }
      
      // Force Sync Google Doc button
      const forceSyncGoogleDocBtn = document.getElementById('force-sync-google-doc-btn');
      if (forceSyncGoogleDocBtn) {
        forceSyncGoogleDocBtn.addEventListener('click', () => syncGoogleDoc(true));
      }
      
      // Migrate to Google Docs button
      const migrateToDocsBtn = document.getElementById('migrate-to-docs-btn');
      if (migrateToDocsBtn) {
        migrateToDocsBtn.addEventListener('click', async () => {
          try {
            migrateToDocsBtn.disabled = true;
            migrateToDocsBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Migrating...';
            
            const response = await fetch(`/api/google/tournaments/${tournamentId}/migrate-to-docs`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
              }
            });
            
            const data = await response.json();
            
            if (!response.ok) {
              const errorData = data;
              throw new Error(errorData.error || 'Failed to migrate to Google Docs');
            }
            
            showToast('Successfully migrated to Google Docs', 'success');
            // Reload the page to show the new Google Doc
            loadTournamentDetails();
          } catch (error) {
            console.error('Error migrating to Google Docs:', error);
            showToast(`Error migrating to Google Docs: ${error.message}`, 'danger');
          } finally {
            migrateToDocsBtn.disabled = false;
            migrateToDocsBtn.innerHTML = 'Migrate to Google Docs';
          }
        });
      }
    }
    
    // Sync players from Google Doc
    async function syncGoogleDoc(forceSync = false) {
      const syncButton = forceSync ? 
        document.getElementById('force-sync-google-doc-btn') : 
        document.getElementById('sync-google-doc-btn');
      
      if (!tournamentId) {
        showToast('Tournament ID is required', 'danger');
        return;
      }
      
      try {
        syncButton.disabled = true;
        syncButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Syncing...';
        
        const response = await fetch(`/api/google/tournaments/${tournamentId}/sync-doc`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({ forceSync })
        });
        
        const data = await response.json();
        
        if (!response.ok) {
          const errorData = data;
          throw new Error(errorData.error || 'Failed to sync Google Doc');
        }
        
        showToast(data.message || `Successfully synced players from Google Doc`, 'success');
        // Reload the page to show the updated players
        loadTournamentDetails();
      } catch (error) {
        console.error('Error syncing Google Doc:', error);
        showToast(`Error syncing Google Doc: ${error.message}`, 'danger');
      } finally {
        syncButton.disabled = false;
        syncButton.innerHTML = forceSync ? 
          '<i class="bi bi-arrow-repeat"></i> Force Sync' : 
          '<i class="bi bi-arrow-repeat"></i> Sync Now';
      }
    }
    
    // Run initialization
    document.addEventListener('DOMContentLoaded', function() {
      // Fetch tournament details when the page loads
      fetchTournamentDetails();
    });
    
    // Function to initialize the page
    async function initPage() {
      try {
        // Get tournament details
        const data = await fetchTournamentDetails();
        if (data) {
          renderTournamentDetails(data);
        }
      } catch (error) {
        console.error('Error initializing page:', error);
        showToast('Error loading tournament details. Please try again.', 'danger');
      }
    }
    
    // Execute init when DOM is loaded
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initPage);
    } else {
      initPage();
    }
  </script>
  
  <!-- Additional script for the updateSubmitButton function -->
  <script>
    // This function is used to update the visibility of submit buttons in each round
    window.updateSubmitButton = function() {
      const count = Object.keys(window.pendingResults || {}).length;
      
      if (count > 0) {
        // Show the submit button in all round containers that have pending results
        document.querySelectorAll('.round-container').forEach(container => {
          // Check if this round has any pending results
          const roundMatches = container.querySelectorAll('[data-match-id]');
          let roundHasPendingResults = false;
          
          roundMatches.forEach(element => {
            const matchId = element.getAttribute('data-match-id');
            if (window.pendingResults && window.pendingResults[matchId]) {
              roundHasPendingResults = true;
            }
          });
          
          // If this round has pending results, show the submit button
          const submitBtn = container.querySelector('.submit-results-btn');
          if (submitBtn && roundHasPendingResults) {
            submitBtn.style.display = 'block';
            submitBtn.innerText = 'Submit Results';
            // Add pulse animation
            submitBtn.classList.add('btn-pulse');
          }
        });
      } else {
        // Hide all submit buttons
        document.querySelectorAll('.submit-results-btn').forEach(btn => {
          btn.style.display = 'none';
          btn.classList.remove('btn-pulse');
        });
      }
    };
  </script>
</body>
</html>
